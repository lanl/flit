/*--------------------------------------------------------------------------*\
 |                                                                          |
 |  Copyright (C) 2016                                                      |
 |                                                                          |
 |         , __                 , __                                        |
 |        /|/  \               /|/  \                                       |
 |         | __/ _   ,_         | __/ _   ,_                                |
 |         |   \|/  /  |  |   | |   \|/  /  |  |   |                        |
 |         |(__/|__/   |_/ \_/|/|(__/|__/   |_/ \_/|/                       |
 |                           /|                   /|                        |
 |                           \|                   \|                        |
 |                                                                          |
 |      Enrico Bertolazzi                                                   |
 |      Dipartimento di Ingegneria Industriale                              |
 |      Universita` degli Studi di Trento                                   |
 |      email: enrico.bertolazzi@unitn.it                                   |
 |                                                                          |
\*--------------------------------------------------------------------------*/

#include "Splines.hh"
#include <iomanip>

#ifdef __GCC__
#pragma GCC diagnostic ignored "-Wc++98-compat"
#endif
#ifdef __clang__
#pragma clang diagnostic ignored "-Wc++98-compat"
#endif

/**
 *
 */

namespace Splines
{

using namespace std; // load standard namspace

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void
ConstantSpline::reserve_external(
    integer      n,
    real_type *& p_x,
    real_type *& p_y
)
{
    if(!_external_alloc)
    {
        baseValue.free();
    }
    npts            = 0;
    npts_reserved   = n;
    _external_alloc = true;
    X = p_x;
    Y = p_y;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void
ConstantSpline::reserve(integer n)
{
    if(_external_alloc && n <= npts_reserved)
    {
        // nothing to do!, already allocated
    }
    else
    {
        baseValue.allocate(size_t(2 * n));
        npts_reserved   = n;
        _external_alloc = false;
        X = baseValue(size_t(n));
        Y = baseValue(size_t(n));
    }
    npts = lastInterval = 0;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//! Evalute spline value at `x`
real_type
ConstantSpline::operator()(real_type x) const
{
    if(x < X[0])
    {
        return Y[0];
    }
    if(npts > 0 && x > X[npts - 1])
    {
        return Y[npts - 1];
    }
    return Y[search(x)];
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void
ConstantSpline::build(real_type const x[], integer incx,
                      real_type const y[], integer incy,
                      integer n)
{
    reserve(n);
    for(size_t i = 0; i   < size_t(n); ++i)
    {
        X[i] = x[i * size_t(incx)];
    }
    for(size_t i = 0; i + 1 < size_t(n); ++i)
    {
        Y[i] = y[i * size_t(incy)];
    }
    npts = n;
    build();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void
ConstantSpline::clear()
{
    if(!_external_alloc)
    {
        baseValue.free();
    }
    npts = npts_reserved = 0;
    _external_alloc = false;
    X = Y = nullptr;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

void
ConstantSpline::writeToStream(ostream_type & s) const
{
    size_t nseg = size_t(npts > 0 ? npts - 1 : 0);
    for(size_t i = 0; i < nseg; ++i)
        s << "segment N." << setw(4) << i
          << " X:[ " << X[i] << ", " << X[i + 1] << " ] Y:" << Y[i]
          << '\n';
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

integer // order
ConstantSpline::coeffs(real_type cfs[], real_type nodes[], bool) const
{
    size_t nseg = size_t(npts > 0 ? npts - 1 : 0);
    for(size_t i = 0; i < nseg; ++i)
    {
        nodes[i] = X[i];
        cfs[i]   = Y[i];
    }
    return 1;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

integer // order
ConstantSpline::order() const
{
    return 1;
}

}
